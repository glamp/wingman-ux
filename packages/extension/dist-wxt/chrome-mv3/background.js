var background=(function(){"use strict";function O(s){return s==null||typeof s=="function"?{main:s}:s}const A={error:0,warn:1,info:2,debug:3};function M(){return typeof __WINGMAN_CONFIG__<"u"?__WINGMAN_CONFIG__:{environment:"production",features:{verboseLogging:!1}}}function U(){const s=M();if(s.features?.verboseLogging)return"debug";switch(s.environment){case"development":return"debug";case"staging":case"test":return"info";case"production":default:return"error"}}class y{constructor(e={}){const t=M();this.namespace=e.namespace||"Wingman",this.enabled=e.enabled!==!1,this.environment=t.environment||"production";const r=e.level||U();this.level=A[r]}shouldLog(e){return this.enabled?A[e]<=this.level:!1}formatMessage(e,t){const r=`[${this.namespace}]`;return this.environment==="development"?`${r} [${e.toUpperCase()}] ${t}`:`${r} ${t}`}error(e,...t){this.shouldLog("error")&&console.error(this.formatMessage("error",e),...t)}warn(e,...t){this.shouldLog("warn")&&console.warn(this.formatMessage("warn",e),...t)}info(e,...t){this.shouldLog("info")&&console.log(this.formatMessage("info",e),...t)}debug(e,...t){this.shouldLog("debug")&&console.log(this.formatMessage("debug",e),...t)}child(e,t){return new y({...t,namespace:`${this.namespace}:${e}`,level:t?.level||(this.level===0?"error":this.level===1?"warn":this.level===2?"info":"debug"),enabled:t?.enabled!==void 0?t.enabled:this.enabled})}}function D(s,e){return new y({...e,namespace:s})}new y({namespace:"Wingman"});const i=D("TunnelManager");class I{constructor(){this.ws=null,this.currentTunnel=null,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectTimeout=null,this.currentRelayUrl="",this.isLocalRelay=!1}async createTunnel(e,t){if(i.info(`[TunnelManager] createTunnel called with port: ${e}, relay: ${t}`),!e||e<=0||e>65535){const r=`Invalid port number: ${e}. Port must be between 1 and 65535.`;throw i.error(`[TunnelManager] ${r}`),new Error(r)}try{i.debug("[TunnelManager] Stopping any existing tunnel..."),this.stopTunnel(),i.info(`[TunnelManager] Creating tunnel for port ${e}`),this.currentTunnel={sessionId:"",tunnelUrl:"",targetPort:e,status:"connecting"},this.updateBadge();const r=t||"https://api.wingmanux.com",n=r.includes("localhost")||r.includes("127.0.0.1");this.currentRelayUrl=r,this.isLocalRelay=n;const o=`${r}/tunnel/create`,c=JSON.stringify({targetPort:e,enableP2P:!1});i.debug(`[TunnelManager] Using ${n?"LOCAL":"EXTERNAL"} relay`),i.debug(`[TunnelManager] Sending POST request to ${o}`),i.debug(`[TunnelManager] Request body: ${c}`);const a=await fetch(o,{method:"POST",headers:{"Content-Type":"application/json"},body:c});if(i.debug(`[TunnelManager] Response status: ${a.status}`),!a.ok){const h=await a.text();throw i.error(`[TunnelManager] API error response: ${h}`),new Error(`Failed to create tunnel: ${h}`)}const l=await a.json();return i.debug("[TunnelManager] API response data:",l),this.currentTunnel.sessionId=l.sessionId,this.currentTunnel.tunnelUrl=l.tunnelUrl,i.info(`[TunnelManager] Tunnel created: ${l.tunnelUrl} (session: ${l.sessionId})`),i.debug("[TunnelManager] Connecting WebSocket..."),await this.connectWebSocket(r,n),this.currentTunnel.status="active",this.updateBadge(),i.info("[TunnelManager] Tunnel successfully activated"),this.currentTunnel}catch(r){throw i.error("[TunnelManager] Failed to create tunnel:",r),i.error("[TunnelManager] Error stack:",r.stack),this.currentTunnel&&(this.currentTunnel.status="error",this.updateBadge()),r}}async connectWebSocket(e,t){return new Promise((r,n)=>{if(!this.currentTunnel){const a=new Error("No tunnel session");i.error(`[TunnelManager] WebSocket connect failed: ${a.message}`),n(a);return}const o=e.replace("http://","ws://").replace("https://","wss://")+"/ws";i.info(`[TunnelManager] Connecting to WebSocket at ${o}... (${t?"LOCAL":"EXTERNAL"})`);try{this.ws=new WebSocket(o),i.debug("[TunnelManager] WebSocket object created")}catch(a){i.error("[TunnelManager] Failed to create WebSocket:",a),n(a);return}const c=setTimeout(()=>{i.error("[TunnelManager] WebSocket connection timeout after 10 seconds"),n(new Error("WebSocket connection timeout"))},1e4);this.ws.onopen=()=>{if(clearTimeout(c),i.info("[TunnelManager] WebSocket connected successfully"),this.ws&&this.currentTunnel){const a=JSON.stringify({type:"register",role:"developer",sessionId:this.currentTunnel.sessionId});i.debug(`[TunnelManager] Sending registration: ${a}`),this.ws.send(a)}else i.error("[TunnelManager] Cannot register - WebSocket or tunnel missing")},this.ws.onmessage=a=>{i.debug(`[TunnelManager] WebSocket message received: ${a.data}`);try{const l=JSON.parse(a.data);l.type==="registered"&&l.role==="developer"?(i.info("[TunnelManager] Successfully registered as developer"),this.reconnectAttempts=0,r()):l.type==="error"?(i.error("[TunnelManager] WebSocket error message:",l.error),n(new Error(l.error))):l.type==="request"?(i.info(`[TunnelManager] Tunnel request: ${l.request?.method} ${l.request?.path}`),this.handleTunnelRequest(l)):i.debug(`[TunnelManager] Unhandled message type: ${l.type}`)}catch(l){i.error("[TunnelManager] Error parsing WebSocket message:",l),i.error(`[TunnelManager] Raw message: ${a.data}`)}},this.ws.onerror=a=>{clearTimeout(c),i.error("[TunnelManager] WebSocket error event:",a),n(a)},this.ws.onclose=a=>{i.info(`[TunnelManager] WebSocket closed - Code: ${a.code}, Reason: ${a.reason}`),this.currentTunnel&&this.currentTunnel.status==="active"&&(i.debug("[TunnelManager] Will attempt to reconnect..."),this.scheduleReconnect())}})}async handleTunnelRequest(e){const{requestId:t,request:r,sessionId:n}=e;if(!this.currentTunnel||!this.ws){i.error("[TunnelManager] Cannot handle request - no active tunnel or WebSocket");return}try{const o=`http://localhost:${this.currentTunnel.targetPort}${r.path||"/"}`;i.debug(`[TunnelManager] Forwarding request to: ${o}`);const c={};r.headers&&Object.entries(r.headers).forEach(([d,w])=>{const g=d.toLowerCase();["host","connection","content-length","accept-encoding"].includes(g)||(c[d]=w)});const a={method:r.method||"GET",headers:c};r.body&&r.method!=="GET"&&r.method!=="HEAD"&&(a.body=typeof r.body=="string"?r.body:JSON.stringify(r.body));const l=await fetch(o,a),h=await l.arrayBuffer();i.debug(`[TunnelManager] Response body: ${h.byteLength} bytes, content-type: ${l.headers.get("content-type")||"unknown"}`);const f={};l.headers.forEach((d,w)=>{f[w]=d});const v={type:"response",requestId:t,sessionId:n,response:{statusCode:l.status,headers:f,bodyLength:h.byteLength}};i.debug(`[TunnelManager] Sending binary response for request ${t}: ${l.status} (${h.byteLength} bytes)`),this.ws.send(JSON.stringify(v)),h.byteLength>0&&this.ws.send(h)}catch(o){i.error("[TunnelManager] Error forwarding request:",o);const c=JSON.stringify({error:"Failed to forward request",details:o.message,targetPort:this.currentTunnel?.targetPort}),a=new TextEncoder().encode(c),l={type:"response",requestId:t,sessionId:n,response:{statusCode:502,headers:{"Content-Type":"application/json"},bodyLength:a.byteLength}};this.ws.send(JSON.stringify(l)),this.ws.send(a)}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){i.error("Max reconnect attempts reached"),this.currentTunnel&&(this.currentTunnel.status="error",this.updateBadge());return}const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),1e4);this.reconnectAttempts++,i.info(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms`),this.reconnectTimeout=window.setTimeout(()=>{this.currentTunnel&&this.connectWebSocket(this.currentRelayUrl,this.isLocalRelay).catch(t=>{i.error("Reconnect failed:",t),this.scheduleReconnect()})},e)}stopTunnel(){this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null),this.currentTunnel=null,this.reconnectAttempts=0,this.updateBadge(),i.info("Tunnel stopped")}updateBadge(){const e=this.currentTunnel?.status||"inactive",r={inactive:{text:"",color:"#8B5CF6"},connecting:{text:"●",color:"#F59E0B"},active:{text:"●",color:"#10B981"},error:{text:"●",color:"#EF4444"}}[e];chrome.action.setBadgeText({text:r.text}),chrome.action.setBadgeBackgroundColor({color:r.color})}getCurrentTunnel(){return this.currentTunnel}}const b={error:0,warn:1,info:2,debug:3};function C(){return typeof window<"u"&&typeof window.__WINGMAN_CONFIG__<"u"?window.__WINGMAN_CONFIG__.environment||"production":typeof process<"u"&&process.env&&process.env.WINGMAN_ENV||"production"}function _(){const s=C();if(typeof process<"u"&&process.env?.LOG_LEVEL)return process.env.LOG_LEVEL;switch(s){case"development":return"debug";case"staging":case"test":return"info";case"production":default:return"error"}}class T{constructor(e={}){this.namespace=e.namespace||"Wingman",this.enabled=e.enabled!==!1,this.environment=e.forceEnvironment||C();const t=e.level||_();this.level=b[t]}shouldLog(e){return this.enabled?b[e]<=this.level:!1}formatMessage(e,t){const r=new Date().toISOString(),n=`[${this.namespace}]`;return this.environment==="development"?`${r} ${n} [${e.toUpperCase()}] ${t}`:`${n} ${t}`}error(e,...t){this.shouldLog("error")&&console.error(this.formatMessage("error",e),...t)}warn(e,...t){this.shouldLog("warn")&&console.warn(this.formatMessage("warn",e),...t)}info(e,...t){this.shouldLog("info")&&console.log(this.formatMessage("info",e),...t)}debug(e,...t){this.shouldLog("debug")&&console.log(this.formatMessage("debug",e),...t)}child(e,t){return new T({...t,namespace:`${this.namespace}:${e}`,level:t?.level||(this.level===0?"error":this.level===1?"warn":this.level===2?"info":"debug"),enabled:t?.enabled!==void 0?t.enabled:this.enabled,forceEnvironment:this.environment})}setLevel(e){this.level=b[e]}setEnabled(e){this.enabled=e}getConfig(){return{level:Object.entries(b).find(([t,r])=>r===this.level)?.[0],namespace:this.namespace,enabled:this.enabled,environment:this.environment}}}new T;function q(s,e){return new T({...e,namespace:s})}var R;(function(s){s.INVALID_MESSAGE="INVALID_MESSAGE",s.UNKNOWN_SESSION="UNKNOWN_SESSION",s.REQUEST_TIMEOUT="REQUEST_TIMEOUT",s.REQUEST_TOO_LARGE="REQUEST_TOO_LARGE",s.TOO_MANY_REQUESTS="TOO_MANY_REQUESTS",s.CONNECTION_FAILED="CONNECTION_FAILED",s.TUNNEL_NOT_FOUND="TUNNEL_NOT_FOUND",s.PERMISSION_DENIED="PERMISSION_DENIED"})(R||(R={}));function k(s,e){if(!s||!e)return;const t=e.split(".");let r=s;for(const n of t){if(r==null)return;r=r[n]}return r}class W{constructor(e){this.truncationConfig=e?.truncationConfig}render(e,t,r){let n=t.template;for(const o of t.variables){let c;if(o.key==="screenshotUrl"&&r&&"screenshotUrl"in r&&r.screenshotUrl)c=r.screenshotUrl.toString();else if(r&&o.key in r&&r[o.key]!=="")c=r[o.key]?.toString()||"";else{const l=this.getValue(e,o.path);c=o.formatter?o.formatter(l,r):l?.toString()||o.defaultValue||""}const a=`{{${o.key}}}`;n=n.replace(new RegExp(a,"g"),c)}return n=this.processNestedProperties(n,e),n=this.processConditionals(n,e,t),n=this.processLoops(n,e,t),n}processNestedProperties(e,t){const r=/\{\{([^#/][^}]+\.[^}]+)\}\}/g;return e.replace(r,(n,o)=>{const c=o.trim(),a=k(t,c);if(!a&&c.startsWith("target.rect.")){const l=k(t,"target.rect");if(l){const h=c.split(".").pop();return l[h]?.toString()||""}}return a?.toString()||""})}processConditionals(e,t,r){const n=/\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/g;return e.replace(n,(o,c,a)=>{const l=r.variables.find(d=>d.key===c);if(!l)return"";const h=this.getValue(t,l.path),f=l.formatter?l.formatter(h):h;return f&&(Array.isArray(f)?f.length>0:!0)?a:""})}processLoops(e,t,r){const n=/\{\{#each\s+(\w+)\}\}([\s\S]*?)\{\{\/each\}\}/g;return e.replace(n,(o,c,a)=>{const l=r.variables.find(f=>f.key===c);if(!l)return"";const h=this.getValue(t,l.path);return Array.isArray(h)?h.map((f,v)=>{let d=a;d=d.replace(/\{\{index\}\}/g,(v+1).toString());const w=/\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/g;if(d=d.replace(w,(g,p,N)=>f[p]?N:""),typeof f=="object"&&f!==null){if("ts"in f&&typeof f.ts=="number"){const g=new Date(f.ts).toLocaleTimeString();d=d.replace(/\{\{timestamp\}\}/g,g)}for(const[g,p]of Object.entries(f)){const N=`{{${g}}}`;let m="";p==null?m="":g==="ts"&&typeof p=="number"?m=new Date(p).toLocaleTimeString():g==="level"&&typeof p=="string"?m=p.toUpperCase():g==="args"&&Array.isArray(p)?m=p.map($=>typeof $=="object"?JSON.stringify($):String($)).join(" "):g==="timestamp"&&typeof p=="number"?m=new Date(p).toLocaleTimeString():m=p.toString(),d=d.replace(new RegExp(N,"g"),m)}d=d.replace(/\{\{[^}]+\}\}/g,g=>g==="{{index}}"?g:"")}return d}).join(""):""})}validate(e){const t=[];e.id||t.push("Template ID is required"),e.name||t.push("Template name is required"),e.template||t.push("Template string is required"),(!e.variables||!Array.isArray(e.variables))&&t.push("Template variables must be an array");const r=this.extractVariables(e.template),n=new Set(e.variables.map(o=>o.key));for(const o of r)!n.has(o)&&!["index","timestamp","message","stack","level","args","url","status","duration","initiatorType"].includes(o)&&t.push(`Variable '${o}' is used in template but not defined`);for(const o of e.variables)o.required&&!r.includes(o.key)&&t.push(`Required variable '${o.key}' is not used in template`);return{valid:t.length===0,...t.length>0&&{errors:t}}}extractVariables(e){const t=new Set,r=/\{\{([^#/][^}]+)\}\}/g;let n;for(;(n=r.exec(e))!==null;){const a=n[1]?.trim();a&&!a.startsWith("#")&&!a.startsWith("/")&&t.add(a)}const o=/\{\{#if\s+(\w+)\}\}/g;for(;(n=o.exec(e))!==null;)n[1]&&t.add(n[1]);const c=/\{\{#each\s+(\w+)\}\}/g;for(;(n=c.exec(e))!==null;)n[1]&&t.add(n[1]);return Array.from(t)}getValue(e,t){const r=k(e,t);if(Array.isArray(r)&&this.truncationConfig){if(t==="console"&&this.truncationConfig.console?.templateLimit){const n=this.truncationConfig.console.templateLimit;return r.slice(-n)}if(t==="network"&&this.truncationConfig.network?.templateLimit){const n=this.truncationConfig.network.templateLimit;return r.slice(-n)}if(t==="errors"&&this.truncationConfig.errors?.templateLimit){const n=this.truncationConfig.errors.templateLimit;return r.slice(-n)}}return r}}function x(s){return new W(s)}const F={id:"default-claude-optimized",name:"Claude Code Optimized",description:"Optimized format for Claude Code with emphasis on user feedback and screenshot analysis",builtIn:!0,tags:["claude","default","optimized"],template:`# 🎯 UI Feedback Request

{{#if userNote}}
## 📝 User Feedback

> **{{userNote}}**

---

{{/if}}
## 🖼️ Screenshot Analysis Required

**IMPORTANT**: Please carefully examine the screenshot below to understand the visual context of the UI issue.

![Wingman Screenshot - Click to view full size]({{screenshotUrl}})

*The screenshot above shows the exact area where the user is reporting an issue.*

---

## 🎨 Visual Context

{{#if targetRect}}
- **Selected Area:** {{targetRectWidth}}×{{targetRectHeight}} pixels at position ({{targetRectX}}, {{targetRectY}})
{{/if}}
- **Selection Mode:** {{selectionModeText}}
{{#if targetSelector}}
- **CSS Selector:** \`{{targetSelector}}\`
{{/if}}

---

## 📍 Page Information

- **URL:** {{pageUrl}}
- **Title:** {{pageTitle}}
- **Viewport:** {{viewportWidth}}×{{viewportHeight}} (DPR: {{viewportDpr}})
- **Captured:** {{capturedAt}}

## 🔧 Technical Details

{{#if hasReact}}
### React Component Info

- **Component:** {{reactComponentName}}
- **Data Source:** {{reactDataSource}}

**Props:**
\`\`\`json
{{reactPropsJson}}
\`\`\`

**State:**
\`\`\`json
{{reactStateJson}}
\`\`\`

{{/if}}
{{#if hasErrors}}
### ⚠️ JavaScript Errors ({{errorCount}})

{{#each errors}}
{{index}}. **[{{timestamp}}]** {{message}}
   {{stack}}
{{/each}}

{{/if}}
{{#if hasConsole}}
### Console Logs ({{consoleCount}})

{{#each consoleLogs}}
{{index}}. **[{{level}}]** {{timestamp}}: {{args}}
{{/each}}

{{/if}}
{{#if hasNetwork}}
### Network Activity ({{networkCount}} requests)

{{#each networkRequests}}
{{index}}. **{{url}}**
   - Status: {{status}}
   - Duration: {{duration}}ms
   - Type: {{initiatorType}}
{{/each}}

{{/if}}
### Browser Info

- **User Agent:** {{userAgent}}
- **Annotation ID:** {{annotationId}}

---

## 💡 Action Request

Please review the **screenshot** and **user feedback** above to understand and address the reported UI issue. Focus on the visual elements shown in the screenshot and how they relate to the user's feedback.
`,variables:[{key:"userNote",path:"note",required:!1,description:"User feedback or note about the issue"},{key:"screenshotUrl",path:"id",formatter:(s,e)=>`${e?.relayUrl||"https://api.wingmanux.com"}/annotations/${s}/screenshot`,required:!0,description:"URL to the screenshot image"},{key:"targetRect",path:"target.rect",required:!1,description:"Rectangle coordinates of selected area"},{key:"targetRectWidth",path:"target.rect.width",required:!1,description:"Width of selected area"},{key:"targetRectHeight",path:"target.rect.height",required:!1,description:"Height of selected area"},{key:"targetRectX",path:"target.rect.x",required:!1,description:"X coordinate of selected area"},{key:"targetRectY",path:"target.rect.y",required:!1,description:"Y coordinate of selected area"},{key:"selectionModeText",path:"target.mode",formatter:s=>s==="element"?"Specific Element":"Region Selection",required:!0,description:"Human-readable selection mode"},{key:"targetSelector",path:"target.selector",required:!1,description:"CSS selector for the target element"},{key:"pageUrl",path:"page.url",required:!0,description:"URL of the page"},{key:"pageTitle",path:"page.title",required:!0,description:"Title of the page"},{key:"viewportWidth",path:"page.viewport.w",required:!0,description:"Viewport width"},{key:"viewportHeight",path:"page.viewport.h",required:!0,description:"Viewport height"},{key:"viewportDpr",path:"page.viewport.dpr",required:!0,description:"Device pixel ratio"},{key:"capturedAt",path:"createdAt",formatter:s=>new Date(s).toLocaleString(),required:!0,description:"When the annotation was captured"},{key:"hasReact",path:"react",formatter:s=>String(!!s),required:!1,description:"Whether React info is available"},{key:"reactComponentName",path:"react.componentName",required:!1,description:"React component name"},{key:"reactDataSource",path:"react.obtainedVia",required:!1,description:"How React data was obtained"},{key:"reactPropsJson",path:"react.props",formatter:s=>JSON.stringify(s,null,2),required:!1,description:"React props as JSON"},{key:"reactStateJson",path:"react.state",formatter:s=>JSON.stringify(s,null,2),required:!1,description:"React state as JSON"},{key:"hasErrors",path:"errors",formatter:s=>String(s&&s.length>0),required:!1,description:"Whether there are JavaScript errors"},{key:"errorCount",path:"errors",formatter:s=>String(s?.length||0),required:!1,description:"Number of JavaScript errors"},{key:"errors",path:"errors",required:!1,description:"JavaScript errors array"},{key:"hasConsole",path:"console",formatter:s=>String(s&&s.length>0),required:!1,description:"Whether there are console logs"},{key:"consoleCount",path:"console",formatter:s=>String(s?.length||0),required:!1,description:"Number of console logs"},{key:"consoleLogs",path:"console",required:!1,description:"Console logs array"},{key:"hasNetwork",path:"network",formatter:s=>String(s&&s.length>0),required:!1,description:"Whether there are network requests"},{key:"networkCount",path:"network",formatter:s=>String(s?.length||0),required:!1,description:"Number of network requests"},{key:"networkRequests",path:"network",required:!1,description:"Network requests array"},{key:"userAgent",path:"page.ua",required:!0,description:"User agent string"},{key:"annotationId",path:"id",required:!0,description:"Unique annotation ID"}]},u=q("Wingman:ScreenshotHandler");class V{constructor(e){this.templateEngine=e}async processForClipboard(e,t,r){const n=e.media?.screenshot?.dataUrl;if(!n)return u.warn("No screenshot data URL available"),{content:this.templateEngine.render(e,t,{relayUrl:r||""})};let o=null;return o=await this.saveToDownloads(n),o||(o=await this.saveToStorage(n)),{content:o?this.formatWithLocalFile(e,t,o):this.formatWithBase64(e,t,n),localPath:o||void 0}}async saveToDownloads(e){try{u.info("Attempting to save screenshot to Downloads folder...");const t=e.match(/^data:image\/(\w+);base64,(.+)$/);if(!t)return u.error("Invalid data URL format"),null;const[,r]=t,o=`wingman-screenshot-${Date.now()}.${r}`;u.debug(`Preparing to download: ${o}`);const c=await this.performDownload(e,o);if(!c)return null;const a=await this.waitForDownload(c);return a?u.info(`Screenshot saved successfully to: ${a}`):u.warn("Download completed but no path returned"),a}catch(t){return u.error("Failed to save screenshot to Downloads:",t),t instanceof Error&&u.error("Error details:",{message:t.message,stack:t.stack,name:t.name}),null}}async hideDownloadShelf(){try{if(chrome.downloads.setUiOptions)return await chrome.downloads.setUiOptions({enabled:!1}),u.debug("Download shelf hidden using setUiOptions"),!0;if(chrome.downloads.setShelfEnabled)return await new Promise(e=>{chrome.downloads.setShelfEnabled(!1),e()}),u.debug("Download shelf hidden using setShelfEnabled"),!0}catch(e){u.warn("Failed to hide download shelf:",e)}return!1}async restoreDownloadShelf(){try{chrome.downloads.setUiOptions?(await chrome.downloads.setUiOptions({enabled:!0}),u.debug("Download shelf restored using setUiOptions")):chrome.downloads.setShelfEnabled&&(chrome.downloads.setShelfEnabled(!0),u.debug("Download shelf restored using setShelfEnabled"))}catch(e){u.warn("Failed to restore download shelf:",e)}}async performDownload(e,t){let r=!1;try{r=await this.hideDownloadShelf();const n={url:e,filename:t,saveAs:!1,conflictAction:"uniquify"};u.debug("Download options:",{filename:t,urlLength:e.length,urlPrefix:e.substring(0,50)+"...",shelfHidden:r});const o=await new Promise(c=>{chrome.downloads.download(n,a=>{chrome.runtime.lastError?(u.error("Chrome download API error:",chrome.runtime.lastError),c(null)):a===void 0?(u.error("Download ID is undefined - download was blocked"),c(null)):(u.info(`Download initiated with ID: ${a}`),c(a))})});return r&&setTimeout(()=>{this.restoreDownloadShelf()},500),o}catch(n){return r&&await this.restoreDownloadShelf(),u.error("Exception during download:",n),null}}async waitForDownload(e){return new Promise(t=>{let n=0;const o=()=>{n++,chrome.downloads.search({id:e},c=>{if(chrome.runtime.lastError){u.error("Error searching for download:",chrome.runtime.lastError),t(null);return}if(!c||c.length===0){u.error(`Download ${e} not found`),t(null);return}const a=c[0];if(u.debug(`Download state: ${a.state}, filename: ${a.filename}`),a.state==="complete")a.filename?(u.info(`Download completed: ${a.filename}`),t(a.filename)):(u.warn("Download completed but filename is empty"),t(null));else if(a.state==="interrupted"){if(u.error(`Download interrupted: ${a.error||"Unknown error"}`),a.error){const l={error:a.error,filename:a.filename,mime:a.mime,bytesReceived:a.bytesReceived,totalBytes:a.totalBytes,danger:a.danger,paused:a.paused};u.error("Download error details:",l)}t(null)}else n>=50?(u.error("Download timeout after 50 attempts"),t(null)):setTimeout(o,100)})};o()})}async saveToStorage(e){try{u.info("Attempting to save screenshot to chrome.storage.local...");const r=new Blob([e]).size/(1024*1024);if(r>8)return u.warn(`Screenshot too large for storage: ${r.toFixed(2)} MB`),null;const o=`screenshot_${Date.now()}`;return await chrome.storage.local.set({[o]:e}),u.info(`Screenshot saved to storage with key: ${o}`),`chrome-storage://${o}`}catch(t){return u.error("Failed to save to chrome.storage.local:",t),null}}formatWithLocalFile(e,t,r){u.debug(`Formatting with local file: ${r}`);let n;r.startsWith("chrome-storage://")?n=r:n=`file://${r}`;let o=this.templateEngine.render(e,t,{relayUrl:n,isLocalFile:!0});return o=o.replace(/!\[.*?\]\(.*?\/annotations\/.*?\/screenshot\)/g,`![Screenshot - Local file](${n})`),o}formatWithBase64(e,t,r){u.warn("Using base64 fallback for screenshot");const n={...e,id:`embedded-${Date.now()}`};let o=this.templateEngine.render(n,t,{relayUrl:"",isLocalFile:!1});return o=o.replace(/!\[.*?\]\(.*?\/annotations\/.*?\/screenshot\)/g,`![Screenshot](${r})`),o=o.replace(/!\[.*?\]\(\/annotations\/.*?\/screenshot\)/g,`![Screenshot](${r})`),o}}const E=new I,B=x(),P=new V(B),J=O(()=>{console.log("Background script started with WXT!"),chrome.action.onClicked.addListener(e=>{console.log("Extension icon clicked"),e.id&&chrome.tabs.sendMessage(e.id,{type:"ACTIVATE_OVERLAY"}).catch(t=>console.error("Failed to send message:",t))}),chrome.commands.onCommand.addListener(e=>{console.log("Keyboard shortcut pressed:",e),e==="activate-overlay"&&chrome.tabs.query({active:!0,currentWindow:!0},([t])=>{t?.id&&chrome.tabs.sendMessage(t.id,{type:"ACTIVATE_OVERLAY"}).catch(r=>console.error("Failed to send message:",r))})}),chrome.runtime.onMessage.addListener((e,t,r)=>{if(console.log("Background received message:",e.type),e.type==="ACTIVATE_OVERLAY"&&t.tab?.id)return chrome.tabs.sendMessage(t.tab.id,{type:"ACTIVATE_OVERLAY"}).then(n=>r(n)).catch(n=>{console.error("Failed to activate overlay:",n),r({success:!1,error:n.message})}),!0;if(e.type==="PROCESS_ANNOTATION")return s(e.annotation,e.relayUrl).then(n=>r(n)).catch(n=>{console.error("Failed to process annotation:",n),r({success:!1,error:n.message})}),!0;if(e.type==="CAPTURE_SCREENSHOT")return chrome.tabs.captureVisibleTab({format:"png"}).then(n=>{r(n)}).catch(n=>{console.error("Screenshot failed:",n),r(null)}),!0;if(e.type==="TUNNEL_CREATE")return console.log("Tunnel create request received with port:",e.targetPort),e.targetPort?(chrome.storage.local.get(["relayUrl"]).then(({relayUrl:n})=>{let o=n;return n==="clipboard"?(o="https://api.wingmanux.com",console.log("Skipping clipboard mode for tunnel, using:",o)):o=n||"https://api.wingmanux.com",console.log("Using relay URL for tunnel:",o),E.createTunnel(e.targetPort,o)}).then(n=>{console.log("Tunnel created successfully:",n),r({success:!0,tunnel:n})}).catch(n=>{console.error("Failed to create tunnel:",n),r({success:!1,error:n.message||"Failed to create tunnel"})}),!0):(console.error("TUNNEL_CREATE: No target port provided"),r({success:!1,error:"No target port provided"}),!1);if(e.type==="TUNNEL_STOP"){console.log("Tunnel stop request received");try{E.stopTunnel(),console.log("Tunnel stopped successfully"),r({success:!0})}catch(n){console.error("Failed to stop tunnel:",n),r({success:!1,error:n.message||"Failed to stop tunnel"})}return!1}if(e.type==="TUNNEL_STATUS"){console.log("Tunnel status request received");try{const n=E.getCurrentTunnel();console.log("Current tunnel status:",n),r({success:!0,tunnel:n})}catch(n){console.error("Failed to get tunnel status:",n),r({success:!1,error:n.message||"Failed to get tunnel status"})}return!1}return!1});async function s(e,t){try{console.log("Processing annotation:",{relayUrl:t});let r="";try{r=await chrome.tabs.captureVisibleTab({format:"png"}),console.log("Screenshot captured successfully")}catch(o){console.error("Screenshot capture failed:",o)}const n={...e,media:{screenshot:{dataUrl:r,timestamp:Date.now()}}};if(t==="clipboard"){const{content:o,localPath:c}=await P.processForClipboard(n,F,t);return console.log("Annotation formatted for clipboard",{hasLocalPath:!!c}),{success:!0,mode:"clipboard",text:o,screenshotPath:c}}else{const o=await fetch(`${t}/annotations`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(o.ok)return console.log("Annotation sent to server successfully"),{success:!0,mode:"server",previewUrl:`${t}/share/${e.id}`};throw new Error(`Server responded with ${o.status}`)}}catch(r){throw console.error("Annotation processing failed:",r),r}}});function H(){}globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome;function S(s,...e){}const G={debug:(...s)=>S(console.debug,...s),log:(...s)=>S(console.log,...s),warn:(...s)=>S(console.warn,...s),error:(...s)=>S(console.error,...s)};let L;try{L=J.main(),L instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(s){throw G.error("The background crashed on startup!"),s}return L})();

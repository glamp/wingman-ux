var background=(function(){"use strict";function w(l){return l==null||typeof l=="function"?{main:l}:l}const m={error:0,warn:1,info:2,debug:3};function b(){return typeof __WINGMAN_CONFIG__<"u"?__WINGMAN_CONFIG__:{environment:"production",features:{verboseLogging:!1}}}function M(){const l=b();if(l.features?.verboseLogging)return"debug";switch(l.environment){case"development":return"debug";case"staging":case"test":return"info";case"production":default:return"error"}}class d{constructor(r={}){const a=b();this.namespace=r.namespace||"Wingman",this.enabled=r.enabled!==!1,this.environment=a.environment||"production";const e=r.level||M();this.level=m[e]}shouldLog(r){return this.enabled?m[r]<=this.level:!1}formatMessage(r,a){const e=`[${this.namespace}]`;return this.environment==="development"?`${e} [${r.toUpperCase()}] ${a}`:`${e} ${a}`}error(r,...a){this.shouldLog("error")&&console.error(this.formatMessage("error",r),...a)}warn(r,...a){this.shouldLog("warn")&&console.warn(this.formatMessage("warn",r),...a)}info(r,...a){this.shouldLog("info")&&console.log(this.formatMessage("info",r),...a)}debug(r,...a){this.shouldLog("debug")&&console.log(this.formatMessage("debug",r),...a)}child(r,a){return new d({...a,namespace:`${this.namespace}:${r}`,level:a?.level||(this.level===0?"error":this.level===1?"warn":this.level===2?"info":"debug"),enabled:a?.enabled!==void 0?a.enabled:this.enabled})}}function $(l,r){return new d({...r,namespace:l})}new d({namespace:"Wingman"});const n=$("TunnelManager");class S{constructor(){this.ws=null,this.currentTunnel=null,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectTimeout=null,this.currentRelayUrl="",this.isLocalRelay=!1}async createTunnel(r,a){if(n.info(`[TunnelManager] createTunnel called with port: ${r}, relay: ${a}`),!r||r<=0||r>65535){const e=`Invalid port number: ${r}. Port must be between 1 and 65535.`;throw n.error(`[TunnelManager] ${e}`),new Error(e)}try{n.debug("[TunnelManager] Stopping any existing tunnel..."),this.stopTunnel(),n.info(`[TunnelManager] Creating tunnel for port ${r}`),this.currentTunnel={sessionId:"",tunnelUrl:"",targetPort:r,status:"connecting"},this.updateBadge();const e=a||"https://api.wingmanux.com",i=e.includes("localhost")||e.includes("127.0.0.1");this.currentRelayUrl=e,this.isLocalRelay=i;const c=`${e}/tunnel/create`,t=JSON.stringify({targetPort:r,enableP2P:!1});n.debug(`[TunnelManager] Using ${i?"LOCAL":"EXTERNAL"} relay`),n.debug(`[TunnelManager] Sending POST request to ${c}`),n.debug(`[TunnelManager] Request body: ${t}`);const o=await fetch(c,{method:"POST",headers:{"Content-Type":"application/json"},body:t});if(n.debug(`[TunnelManager] Response status: ${o.status}`),!o.ok){const u=await o.text();throw n.error(`[TunnelManager] API error response: ${u}`),new Error(`Failed to create tunnel: ${u}`)}const s=await o.json();return n.debug("[TunnelManager] API response data:",s),this.currentTunnel.sessionId=s.sessionId,this.currentTunnel.tunnelUrl=s.tunnelUrl,n.info(`[TunnelManager] Tunnel created: ${s.tunnelUrl} (session: ${s.sessionId})`),n.debug("[TunnelManager] Connecting WebSocket..."),await this.connectWebSocket(e,i),this.currentTunnel.status="active",this.updateBadge(),n.info("[TunnelManager] Tunnel successfully activated"),this.currentTunnel}catch(e){throw n.error("[TunnelManager] Failed to create tunnel:",e),n.error("[TunnelManager] Error stack:",e.stack),this.currentTunnel&&(this.currentTunnel.status="error",this.updateBadge()),e}}async connectWebSocket(r,a){return new Promise((e,i)=>{if(!this.currentTunnel){const o=new Error("No tunnel session");n.error(`[TunnelManager] WebSocket connect failed: ${o.message}`),i(o);return}const c=r.replace("http://","ws://").replace("https://","wss://")+"/ws";n.info(`[TunnelManager] Connecting to WebSocket at ${c}... (${a?"LOCAL":"EXTERNAL"})`);try{this.ws=new WebSocket(c),n.debug("[TunnelManager] WebSocket object created")}catch(o){n.error("[TunnelManager] Failed to create WebSocket:",o),i(o);return}const t=setTimeout(()=>{n.error("[TunnelManager] WebSocket connection timeout after 10 seconds"),i(new Error("WebSocket connection timeout"))},1e4);this.ws.onopen=()=>{if(clearTimeout(t),n.info("[TunnelManager] WebSocket connected successfully"),this.ws&&this.currentTunnel){const o=JSON.stringify({type:"register",role:"developer",sessionId:this.currentTunnel.sessionId});n.debug(`[TunnelManager] Sending registration: ${o}`),this.ws.send(o)}else n.error("[TunnelManager] Cannot register - WebSocket or tunnel missing")},this.ws.onmessage=o=>{n.debug(`[TunnelManager] WebSocket message received: ${o.data}`);try{const s=JSON.parse(o.data);s.type==="registered"&&s.role==="developer"?(n.info("[TunnelManager] Successfully registered as developer"),this.reconnectAttempts=0,e()):s.type==="error"?(n.error("[TunnelManager] WebSocket error message:",s.error),i(new Error(s.error))):s.type==="request"?(n.info(`[TunnelManager] Tunnel request: ${s.request?.method} ${s.request?.path}`),this.handleTunnelRequest(s)):n.debug(`[TunnelManager] Unhandled message type: ${s.type}`)}catch(s){n.error("[TunnelManager] Error parsing WebSocket message:",s),n.error(`[TunnelManager] Raw message: ${o.data}`)}},this.ws.onerror=o=>{clearTimeout(t),n.error("[TunnelManager] WebSocket error event:",o),i(o)},this.ws.onclose=o=>{n.info(`[TunnelManager] WebSocket closed - Code: ${o.code}, Reason: ${o.reason}`),this.currentTunnel&&this.currentTunnel.status==="active"&&(n.debug("[TunnelManager] Will attempt to reconnect..."),this.scheduleReconnect())}})}async handleTunnelRequest(r){const{requestId:a,request:e,sessionId:i}=r;if(!this.currentTunnel||!this.ws){n.error("[TunnelManager] Cannot handle request - no active tunnel or WebSocket");return}try{const c=`http://localhost:${this.currentTunnel.targetPort}${e.path||"/"}`;n.debug(`[TunnelManager] Forwarding request to: ${c}`);const t={};e.headers&&Object.entries(e.headers).forEach(([h,T])=>{const A=h.toLowerCase();["host","connection","content-length","accept-encoding"].includes(A)||(t[h]=T)});const o={method:e.method||"GET",headers:t};e.body&&e.method!=="GET"&&e.method!=="HEAD"&&(o.body=typeof e.body=="string"?e.body:JSON.stringify(e.body));const s=await fetch(c,o),u=await s.arrayBuffer();n.debug(`[TunnelManager] Response body: ${u.byteLength} bytes, content-type: ${s.headers.get("content-type")||"unknown"}`);const y={};s.headers.forEach((h,T)=>{y[T]=h});const E={type:"response",requestId:a,sessionId:i,response:{statusCode:s.status,headers:y,bodyLength:u.byteLength}};n.debug(`[TunnelManager] Sending binary response for request ${a}: ${s.status} (${u.byteLength} bytes)`),this.ws.send(JSON.stringify(E)),u.byteLength>0&&this.ws.send(u)}catch(c){n.error("[TunnelManager] Error forwarding request:",c);const t=JSON.stringify({error:"Failed to forward request",details:c.message,targetPort:this.currentTunnel?.targetPort}),o=new TextEncoder().encode(t),s={type:"response",requestId:a,sessionId:i,response:{statusCode:502,headers:{"Content-Type":"application/json"},bodyLength:o.byteLength}};this.ws.send(JSON.stringify(s)),this.ws.send(o)}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){n.error("Max reconnect attempts reached"),this.currentTunnel&&(this.currentTunnel.status="error",this.updateBadge());return}const r=Math.min(1e3*Math.pow(2,this.reconnectAttempts),1e4);this.reconnectAttempts++,n.info(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${r}ms`),this.reconnectTimeout=window.setTimeout(()=>{this.currentTunnel&&this.connectWebSocket(this.currentRelayUrl,this.isLocalRelay).catch(a=>{n.error("Reconnect failed:",a),this.scheduleReconnect()})},r)}stopTunnel(){this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null),this.currentTunnel=null,this.reconnectAttempts=0,this.updateBadge(),n.info("Tunnel stopped")}updateBadge(){const r=this.currentTunnel?.status||"inactive",e={inactive:{text:"",color:"#8B5CF6"},connecting:{text:"●",color:"#F59E0B"},active:{text:"●",color:"#10B981"},error:{text:"●",color:"#EF4444"}}[r];chrome.action.setBadgeText({text:e.text}),chrome.action.setBadgeBackgroundColor({color:e.color})}getCurrentTunnel(){return this.currentTunnel}}const f=new S,v=w(()=>{console.log("Background script started with WXT!"),chrome.action.onClicked.addListener(e=>{console.log("Extension icon clicked"),e.id&&chrome.tabs.sendMessage(e.id,{type:"ACTIVATE_OVERLAY"}).catch(i=>console.error("Failed to send message:",i))}),chrome.commands.onCommand.addListener(e=>{console.log("Keyboard shortcut pressed:",e),e==="activate-overlay"&&chrome.tabs.query({active:!0,currentWindow:!0},([i])=>{i?.id&&chrome.tabs.sendMessage(i.id,{type:"ACTIVATE_OVERLAY"}).catch(c=>console.error("Failed to send message:",c))})}),chrome.runtime.onMessage.addListener((e,i,c)=>{if(console.log("Background received message:",e.type),e.type==="ACTIVATE_OVERLAY"&&i.tab?.id)return chrome.tabs.sendMessage(i.tab.id,{type:"ACTIVATE_OVERLAY"}).then(t=>c(t)).catch(t=>{console.error("Failed to activate overlay:",t),c({success:!1,error:t.message})}),!0;if(e.type==="PROCESS_ANNOTATION")return l(e.annotation,e.relayUrl,e.templateId).then(t=>c(t)).catch(t=>{console.error("Failed to process annotation:",t),c({success:!1,error:t.message})}),!0;if(e.type==="CAPTURE_SCREENSHOT")return chrome.tabs.captureVisibleTab({format:"png"}).then(t=>{c(t)}).catch(t=>{console.error("Screenshot failed:",t),c(null)}),!0;if(e.type==="TUNNEL_CREATE")return console.log("Tunnel create request received with port:",e.targetPort),e.targetPort?(chrome.storage.local.get(["relayUrl"]).then(({relayUrl:t})=>{let o=t;return t==="clipboard"?(o="https://api.wingmanux.com",console.log("Skipping clipboard mode for tunnel, using:",o)):o=t||"https://api.wingmanux.com",console.log("Using relay URL for tunnel:",o),f.createTunnel(e.targetPort,o)}).then(t=>{console.log("Tunnel created successfully:",t),c({success:!0,tunnel:t})}).catch(t=>{console.error("Failed to create tunnel:",t),c({success:!1,error:t.message||"Failed to create tunnel"})}),!0):(console.error("TUNNEL_CREATE: No target port provided"),c({success:!1,error:"No target port provided"}),!1);if(e.type==="TUNNEL_STOP"){console.log("Tunnel stop request received");try{f.stopTunnel(),console.log("Tunnel stopped successfully"),c({success:!0})}catch(t){console.error("Failed to stop tunnel:",t),c({success:!1,error:t.message||"Failed to stop tunnel"})}return!1}if(e.type==="TUNNEL_STATUS"){console.log("Tunnel status request received");try{const t=f.getCurrentTunnel();console.log("Current tunnel status:",t),c({success:!0,tunnel:t})}catch(t){console.error("Failed to get tunnel status:",t),c({success:!1,error:t.message||"Failed to get tunnel status"})}return!1}return!1});async function l(e,i,c){try{console.log("Processing annotation:",{relayUrl:i,templateId:c});let t="";try{t=await chrome.tabs.captureVisibleTab({format:"png"}),console.log("Screenshot captured successfully")}catch(s){console.error("Screenshot capture failed:",s)}const o={...e,screenshotUrl:t};if(i==="clipboard"){const s=await r(o,c);return console.log("Annotation formatted for clipboard"),{success:!0,mode:"clipboard",text:s}}else{const s=await fetch(`${i}/annotations`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o)});if(s.ok)return console.log("Annotation sent to server successfully"),{success:!0,mode:"server",previewUrl:`${i}/share/${e.id}`};throw new Error(`Server responded with ${s.status}`)}}catch(t){throw console.error("Annotation processing failed:",t),t}}async function r(e,i){return((await chrome.storage.local.get(["customTemplates"])).customTemplates||[]).find(s=>s.id===i)?.content||a(e)}function a(e){return`# UI Feedback

**Note**: ${e.note}

**Page**: ${e.page.title}
**URL**: ${e.page.url}

**Captured**: ${new Date(e.createdAt).toLocaleString()}`}});function C(){}globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome;function g(l,...r){}const L={debug:(...l)=>g(console.debug,...l),log:(...l)=>g(console.log,...l),warn:(...l)=>g(console.warn,...l),error:(...l)=>g(console.error,...l)};let p;try{p=v.main(),p instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(l){throw L.error("The background crashed on startup!"),l}return p})();

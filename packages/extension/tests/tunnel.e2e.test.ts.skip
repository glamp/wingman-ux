// Skip this test - Playwright not configured
// TODO: Set up Playwright for E2E testing
import { test, expect } from '@playwright/test';
import { spawn, ChildProcess } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';

let testServer: ChildProcess;
let testServerPort = 8891;

test.describe('Chrome Extension Tunnel E2E Tests', () => {
  // Start test HTTP server before all tests
  test.beforeAll(async () => {
    // Create a simple HTML file for testing
    const testHtml = `
      <!DOCTYPE html>
      <html>
        <head><title>E2E Test Server</title></head>
        <body>
          <h1>Tunnel E2E Test Page</h1>
          <p id="test-content">This server is running on port ${testServerPort}</p>
        </body>
      </html>
    `;
    
    const testDir = '/tmp/tunnel-e2e-test';
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }
    fs.writeFileSync(path.join(testDir, 'index.html'), testHtml);
    
    // Start Python HTTP server
    testServer = spawn('python3', ['-m', 'http.server', String(testServerPort)], {
      cwd: testDir
    });
    
    // Wait for server to start
    await new Promise(resolve => setTimeout(resolve, 2000));
  });

  // Stop test server after all tests
  test.afterAll(async () => {
    if (testServer) {
      testServer.kill('SIGTERM');
    }
  });

  test('Extension loads and popup opens', async ({ browser }) => {
    const extensionPath = path.resolve(__dirname, '../../dist/development');
    
    // Launch Chrome with extension
    const context = await browser.newContext({
      // Load extension in Chrome
      args: [
        `--disable-extensions-except=${extensionPath}`,
        `--load-extension=${extensionPath}`,
        '--no-sandbox'
      ]
    });
    
    const page = await context.newPage();
    
    // Navigate to test server
    await page.goto(`http://localhost:${testServerPort}`);
    await expect(page.locator('#test-content')).toContainText(String(testServerPort));
    
    // Get extension ID from manifest
    const manifestPath = path.join(extensionPath, 'manifest.json');
    const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
    
    // Note: In a real test, we'd need to get the actual extension ID
    // For now, we'll test the functionality directly
    
    await context.close();
  });
  
  test('Tunnel creation via API', async ({ request }) => {
    // Test tunnel creation API directly
    const response = await request.post('https://api.wingmanux.com/tunnel/create', {
      data: {
        targetPort: testServerPort,
        enableP2P: false
      }
    });
    
    expect(response.ok()).toBeTruthy();
    
    const tunnel = await response.json();
    expect(tunnel).toHaveProperty('sessionId');
    expect(tunnel).toHaveProperty('tunnelUrl');
    expect(tunnel.tunnelUrl).toMatch(/https:\/\/.*\.wingmanux\.com/);
  });
  
  test('WebSocket connection and registration', async ({ page }) => {
    // Test WebSocket connection
    const result = await page.evaluate(async () => {
      return new Promise((resolve) => {
        // First create a tunnel
        fetch('https://api.wingmanux.com/tunnel/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ targetPort: 8891, enableP2P: false })
        })
        .then(res => res.json())
        .then(tunnel => {
          // Connect WebSocket
          const ws = new WebSocket('wss://api.wingmanux.com/ws');
          
          ws.onopen = () => {
            // Register as developer
            ws.send(JSON.stringify({
              type: 'register',
              role: 'developer',
              sessionId: tunnel.sessionId
            }));
          };
          
          ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            if (msg.type === 'registered' && msg.role === 'developer') {
              ws.close();
              resolve({ success: true, tunnel });
            }
          };
          
          ws.onerror = () => {
            resolve({ success: false, error: 'WebSocket error' });
          };
          
          // Timeout after 10 seconds
          setTimeout(() => {
            ws.close();
            resolve({ success: false, error: 'Timeout' });
          }, 10000);
        })
        .catch(error => {
          resolve({ success: false, error: error.message });
        });
      });
    });
    
    expect(result.success).toBeTruthy();
    expect(result.tunnel).toHaveProperty('sessionId');
    expect(result.tunnel).toHaveProperty('tunnelUrl');
  });
  
  test('Port validation', async ({ page }) => {
    // Test invalid port numbers
    const testPorts = [
      { port: 0, shouldFail: true },
      { port: -1, shouldFail: true },
      { port: 70000, shouldFail: true },
      { port: 3000, shouldFail: false },
      { port: 8080, shouldFail: false },
      { port: 65535, shouldFail: false }
    ];
    
    for (const { port, shouldFail } of testPorts) {
      const result = await page.evaluate(async (testPort) => {
        try {
          // Validate port (same logic as in TunnelManager)
          if (!testPort || testPort <= 0 || testPort > 65535) {
            throw new Error(`Invalid port: ${testPort}`);
          }
          return { success: true };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }, port);
      
      if (shouldFail) {
        expect(result.success).toBeFalsy();
        expect(result.error).toContain('Invalid port');
      } else {
        expect(result.success).toBeTruthy();
      }
    }
  });
  
  test('Error handling and reconnection', async ({ page }) => {
    // Simulate WebSocket disconnection and reconnection
    const result = await page.evaluate(async () => {
      let reconnectAttempts = 0;
      const maxReconnectAttempts = 3;
      
      function attemptConnection(): Promise<boolean> {
        return new Promise((resolve) => {
          const ws = new WebSocket('wss://api.wingmanux.com/ws');
          
          ws.onopen = () => {
            // Simulate immediate close to trigger reconnection
            if (reconnectAttempts < 2) {
              ws.close();
            } else {
              // Success on third attempt
              resolve(true);
            }
          };
          
          ws.onclose = () => {
            reconnectAttempts++;
            if (reconnectAttempts < maxReconnectAttempts) {
              // Exponential backoff
              const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 5000);
              setTimeout(() => {
                attemptConnection().then(resolve);
              }, delay);
            } else {
              resolve(false);
            }
          };
          
          ws.onerror = () => {
            ws.close();
          };
        });
      }
      
      return await attemptConnection();
    });
    
    expect(result).toBeTruthy();
  });
  
  test('Tunnel status badge updates', async ({ page }) => {
    // Test badge state transitions
    const states = ['inactive', 'connecting', 'active', 'error'];
    const expectedBadges = {
      inactive: { text: '', color: '#8B5CF6' },
      connecting: { text: '●', color: '#F59E0B' },
      active: { text: '●', color: '#10B981' },
      error: { text: '●', color: '#EF4444' }
    };
    
    for (const state of states) {
      const badge = expectedBadges[state];
      
      // Verify badge configuration matches expected values
      expect(badge).toBeDefined();
      expect(badge.text).toBeDefined();
      expect(badge.color).toMatch(/^#[0-9A-F]{6}$/i);
    }
  });
});

// Integration test for CLI tunnel functionality
test.describe('CLI Tunnel Integration', () => {
  test('CLI tunnel connects and forwards traffic', async ({ page }) => {
    // This test would require the CLI to be running
    // For now, we'll test the tunnel API directly
    
    const tunnelResponse = await fetch('https://api.wingmanux.com/tunnel/create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ targetPort: testServerPort, enableP2P: false })
    });
    
    expect(tunnelResponse.ok).toBeTruthy();
    
    const tunnel = await tunnelResponse.json();
    
    // Attempt to connect WebSocket and register
    const ws = new WebSocket('wss://api.wingmanux.com/ws');
    
    const registered = await new Promise<boolean>((resolve) => {
      const timeout = setTimeout(() => {
        ws.close();
        resolve(false);
      }, 10000);
      
      ws.onopen = () => {
        ws.send(JSON.stringify({
          type: 'register',
          role: 'developer',
          sessionId: tunnel.sessionId
        }));
      };
      
      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === 'registered' && msg.role === 'developer') {
          clearTimeout(timeout);
          ws.close();
          resolve(true);
        }
      };
      
      ws.onerror = () => {
        clearTimeout(timeout);
        ws.close();
        resolve(false);
      };
    });
    
    expect(registered).toBeTruthy();
  });
});
#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { detect } = require('detect-port');
const chokidar = require('chokidar');
const dayjs = require('dayjs');
const relativeTime = require('dayjs/plugin/relativeTime');

dayjs.extend(relativeTime);

// Configuration
const DEV_DIR = path.join(process.cwd(), '.wingman-dev');
const PID_DIR = path.join(DEV_DIR, 'pids');
const BUILD_STATS_FILE = path.join(DEV_DIR, 'build-stats.json');

const SERVICES = {
  server: {
    name: 'Relay Server',
    command: 'cd packages/relay-server && NODE_ENV=development npm run dev',
    defaultPort: 8787,
    pidFile: 'server.pid',
    watchPaths: ['packages/relay-server/src'],
    distPath: 'packages/relay-server/dist'
  },
  extension: {
    name: 'Chrome Extension', 
    command: 'cd packages/chrome-extension && NODE_ENV=development npm run dev',
    defaultPort: null,
    pidFile: 'extension.pid',
    watchPaths: ['packages/chrome-extension/src'],
    distPath: 'packages/chrome-extension/dist'
  },
  preview: {
    name: 'Preview UI',
    command: 'cd packages/preview-ui && npm run dev',
    defaultPort: 3001,
    pidFile: 'preview.pid',
    watchPaths: ['packages/preview-ui/src'],
    distPath: 'packages/preview-ui/dist'
  },
  demo: {
    name: 'Demo App',
    command: 'cd demo-app && npm run dev',
    defaultPort: 5173,
    pidFile: 'demo.pid',
    watchPaths: ['demo-app/src'],
    distPath: 'demo-app/dist'
  }
};

// Global state
let buildStats = {};
let watchers = [];

// Ensure directories exist
function ensureDirectories() {
  [DEV_DIR, PID_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
}

// Load build stats
function loadBuildStats() {
  if (fs.existsSync(BUILD_STATS_FILE)) {
    try {
      buildStats = JSON.parse(fs.readFileSync(BUILD_STATS_FILE, 'utf8'));
    } catch (e) {
      buildStats = {};
    }
  }
}

// Scan existing build artifacts to initialize build times
function scanBuildTimes() {
  Object.entries(SERVICES).forEach(([key, service]) => {
    const distPath = path.join(process.cwd(), service.distPath);
    
    // Check if dist directory exists
    if (fs.existsSync(distPath)) {
      try {
        // Get the most recent modification time from dist directory
        const stats = fs.statSync(distPath);
        let mostRecentTime = stats.mtime;
        
        // Check a few key files in the dist directory for more accurate timing
        const filesToCheck = ['index.js', 'index.html', 'manifest.json', 'main.js'];
        
        for (const file of filesToCheck) {
          const filePath = path.join(distPath, file);
          if (fs.existsSync(filePath)) {
            const fileStats = fs.statSync(filePath);
            if (fileStats.mtime > mostRecentTime) {
              mostRecentTime = fileStats.mtime;
            }
          }
        }
        
        // Initialize or update build stats
        if (!buildStats[key]) {
          buildStats[key] = {};
        }
        
        // Only update if we don't have a build time or if the status is "building"
        if (!buildStats[key].lastBuild || buildStats[key].status === 'building') {
          buildStats[key].lastBuild = mostRecentTime.toISOString();
          buildStats[key].status = 'success';
        }
      } catch (e) {
        // If we can't read the directory, don't update build stats
        console.error(`Warning: Could not scan ${service.distPath}: ${e.message}`);
      }
    } else {
      // If dist doesn't exist and status is "building", clear it
      if (buildStats[key] && buildStats[key].status === 'building') {
        delete buildStats[key].status;
        delete buildStats[key].lastBuild;
      }
    }
  });
  
  saveBuildStats();
}

// Save build stats
function saveBuildStats() {
  fs.writeFileSync(BUILD_STATS_FILE, JSON.stringify(buildStats, null, 2));
}

// Check if a process is running
function isProcessRunning(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch (e) {
    return false;
  }
}

// Read PID from file
function readPidFile(filename) {
  const pidPath = path.join(PID_DIR, filename);
  if (fs.existsSync(pidPath)) {
    const content = fs.readFileSync(pidPath, 'utf8').trim();
    const pid = parseInt(content);
    if (!isNaN(pid)) {
      return pid;
    }
  }
  return null;
}

// Write PID to file
function writePidFile(filename, pid) {
  const pidPath = path.join(PID_DIR, filename);
  fs.writeFileSync(pidPath, pid.toString());
}

// Remove PID file
function removePidFile(filename) {
  const pidPath = path.join(PID_DIR, filename);
  if (fs.existsSync(pidPath)) {
    fs.unlinkSync(pidPath);
  }
}

// Format build time
function formatBuildTime(serviceKey) {
  const stats = buildStats[serviceKey];
  if (!stats || !stats.lastBuild) {
    return 'Never';
  }
  
  if (stats.status === 'building') {
    return 'Building...';
  }
  
  const buildTime = dayjs(stats.lastBuild);
  const now = dayjs();
  const diffMinutes = now.diff(buildTime, 'minute');
  
  if (diffMinutes < 1) {
    return 'Just now';
  } else if (diffMinutes < 60) {
    return `${diffMinutes}m ago`;
  } else if (diffMinutes < 1440) {
    const hours = Math.floor(diffMinutes / 60);
    return `${hours}h ago`;
  } else {
    return buildTime.format('MMM DD HH:mm');
  }
}

// Get service status
async function getServiceStatus(serviceKey, service) {
  const pid = readPidFile(service.pidFile);
  
  if (pid && isProcessRunning(pid)) {
    let port = service.defaultPort;
    
    // Check if port is actually in use
    if (port) {
      try {
        const availablePort = await detect(port);
        if (availablePort !== port) {
          // Port is in use, likely by our service
          return {
            status: 'running',
            pid,
            port
          };
        } else {
          // Port is free but process is running (might be starting up)
          return {
            status: 'running',
            pid,
            port: port
          };
        }
      } catch (e) {
        // Error checking port, assume service is running
        return {
          status: 'running',
          pid,
          port: port || '-'
        };
      }
    }
    
    return {
      status: 'running',
      pid,
      port: '-'
    };
  } else {
    // Clean up stale PID file
    if (pid) {
      removePidFile(service.pidFile);
    }
    return {
      status: 'stopped',
      pid: null,
      port: null
    };
  }
}

// Print status table
async function printStatus(showTimestamp = false) {
  console.log('\n╔═══════════════════════════════════════════════════════════════════╗');
  console.log('║                    🛩️  Wingman Control Tower                      ║');
  console.log('╠═══════════════════════════════════════════════════════════════════╣');
  console.log('║ Service          │ Status    │  PID  │ Port │ Last Built         ║');
  console.log('╟──────────────────┼───────────┼───────┼──────┼────────────────────╢');
  
  let allRunning = true;
  let anyRunning = false;
  
  for (const [key, service] of Object.entries(SERVICES)) {
    const status = await getServiceStatus(key, service);
    const statusText = status.status === 'running' ? '● Running' : '○ Stopped';
    const statusColor = status.status === 'running' ? '\x1b[32m' : '\x1b[31m';
    const reset = '\x1b[0m';
    
    if (status.status === 'running') {
      anyRunning = true;
    } else {
      allRunning = false;
    }
    
    const pidDisplay = status.pid ? status.pid.toString() : '-';
    const portDisplay = status.port ? status.port.toString() : '-';
    
    const buildTime = formatBuildTime(key);
    
    console.log(
      `║ ${service.name.padEnd(16)} │ ${statusColor}${statusText.padEnd(9)}${reset} │ ${
        pidDisplay.padEnd(5)
      } │ ${portDisplay.padEnd(4)} │ ${buildTime.padEnd(18)} ║`
    );
  }
  
  console.log('╚══════════════════╧═══════════╧═══════╧══════╧════════════════════╝');
  
  if (showTimestamp) {
    console.log(`\n Last updated: ${dayjs().format('HH:mm:ss')}`);
  }
  
  return { allRunning, anyRunning };
}

// Start a service
async function startService(serviceKey, service) {
  const existingPid = readPidFile(service.pidFile);
  
  if (existingPid && isProcessRunning(existingPid)) {
    console.log(`  ${service.name} is already running (PID: ${existingPid})`);
    return existingPid;
  }
  
  if (service.defaultPort) {
    const availablePort = await detect(service.defaultPort);
    if (availablePort !== service.defaultPort) {
      console.log(`  ⚠️  Port ${service.defaultPort} is already in use for ${service.name}`);
    }
  }
  
  console.log(`  Starting ${service.name}...`);
  
  const logFile = path.join(DEV_DIR, `${serviceKey}.log`);
  const cmd = `nohup sh -c '${service.command}' > ${logFile} 2>&1 & echo $!`;
  
  try {
    const pid = execSync(cmd, { 
      encoding: 'utf8',
      shell: '/bin/sh'
    }).trim();
    
    const pidNum = parseInt(pid);
    if (!isNaN(pidNum)) {
      writePidFile(service.pidFile, pidNum);
      console.log(`  ✓ ${service.name} started (PID: ${pidNum})`);
      return pidNum;
    } else {
      console.log(`  ✗ Failed to start ${service.name}: Invalid PID`);
    }
  } catch (error) {
    console.log(`  ✗ Failed to start ${service.name}: ${error.message}`);
  }
  
  return null;
}

// Stop a service
async function stopService(serviceKey, service) {
  const pid = readPidFile(service.pidFile);
  
  if (!pid) {
    console.log(`  ${service.name} is not running`);
    return;
  }
  
  if (!isProcessRunning(pid)) {
    console.log(`  ${service.name} PID file exists but process is not running`);
    removePidFile(service.pidFile);
    return;
  }
  
  try {
    execSync(`pkill -P ${pid} 2>/dev/null || true`, { encoding: 'utf8' });
    process.kill(pid, 'SIGTERM');
    removePidFile(service.pidFile);
    console.log(`  ✓ ${service.name} stopped (PID: ${pid})`);
  } catch (error) {
    console.log(`  ✗ Failed to stop ${service.name}: ${error.message}`);
  }
}

// Start all services
async function startAll() {
  console.log('\n🚀 Starting Wingman services...\n');
  for (const [key, service] of Object.entries(SERVICES)) {
    await startService(key, service);
    await new Promise(resolve => setTimeout(resolve, 1500));
  }
  console.log('\n✅ All services started\n');
}

// Stop all services
async function stopAll() {
  console.log('\n🛑 Stopping Wingman services...\n');
  for (const [key, service] of Object.entries(SERVICES)) {
    await stopService(key, service);
  }
  console.log('\n✅ All services stopped\n');
}

// Setup file watchers for build detection
function setupWatchers() {
  // Clear existing watchers
  watchers.forEach(w => w.close());
  watchers = [];
  
  Object.entries(SERVICES).forEach(([key, service]) => {
    // Watch dist directory for build completions
    const distPath = path.join(process.cwd(), service.distPath);
    
    if (fs.existsSync(path.dirname(distPath))) {
      const watcher = chokidar.watch(distPath, {
        persistent: true,
        ignoreInitial: false, // Changed to false to detect initial files
        depth: 2, // Increased depth to catch more build artifacts
        awaitWriteFinish: {
          stabilityThreshold: 500,
          pollInterval: 100
        }
      });
      
      // Handle both 'add' and 'change' events for build detection
      const updateBuildSuccess = () => {
        if (!buildStats[key]) {
          buildStats[key] = {};
        }
        buildStats[key].lastBuild = new Date().toISOString();
        buildStats[key].status = 'success';
        saveBuildStats();
      };
      
      watcher.on('change', updateBuildSuccess);
      watcher.on('add', updateBuildSuccess);
      
      watchers.push(watcher);
    }
    
    // Watch source directories to detect when builds start
    service.watchPaths.forEach(watchPath => {
      const fullPath = path.join(process.cwd(), watchPath);
      
      if (fs.existsSync(fullPath)) {
        const sourceWatcher = chokidar.watch(fullPath, {
          persistent: true,
          ignoreInitial: true,
          ignored: /node_modules|\.git/
        });
        
        sourceWatcher.on('change', () => {
          if (!buildStats[key]) {
            buildStats[key] = {};
          }
          // Mark as building when source changes, but only if we have a previous successful build
          if (buildStats[key].lastBuild && buildStats[key].status !== 'building') {
            buildStats[key].status = 'building';
            saveBuildStats();
          }
        });
        
        watchers.push(sourceWatcher);
      }
    });
  });
}

// Cleanup watchers
function cleanup() {
  watchers.forEach(w => w.close());
}

// Watch mode
async function watchMode() {
  setupWatchers();
  
  // Clear screen and show initial status
  console.clear();
  await printStatus(true);
  console.log('\n 👀 Watching for changes... (Press Ctrl+C to exit)\n');
  
  // Update every 2 seconds
  const interval = setInterval(async () => {
    console.clear();
    await printStatus(true);
    console.log('\n 👀 Watching for changes... (Press Ctrl+C to exit)\n');
  }, 2000);
  
  // Handle exit
  process.on('SIGINT', () => {
    clearInterval(interval);
    cleanup();
    console.log('\n\n✅ Watch mode stopped\n');
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    clearInterval(interval);
    cleanup();
    process.exit(0);
  });
}

// Main function
async function main() {
  ensureDirectories();
  loadBuildStats();
  scanBuildTimes(); // Scan existing builds on startup
  
  const args = process.argv.slice(2);
  const command = args[0];
  const watchFlag = args.includes('--watch');
  
  switch (command) {
    case 'stop':
      await stopAll();
      break;
      
    case 'status':
      await printStatus();
      console.log('');
      break;
      
    case 'restart':
      await stopAll();
      await new Promise(resolve => setTimeout(resolve, 2000));
      await startAll();
      await printStatus();
      console.log('');
      break;
      
    default:
      // Check if any services need starting
      let needStart = false;
      for (const [key, service] of Object.entries(SERVICES)) {
        const status = await getServiceStatus(key, service);
        if (status.status === 'stopped') {
          needStart = true;
          break;
        }
      }
      
      // Start services if needed
      if (needStart) {
        await startAll();
      }
      
      // Setup watchers to keep build stats updated (even in non-watch mode)
      setupWatchers();
      
      // Show status
      await printStatus();
      console.log('');
      
      // Enter watch mode if requested
      if (watchFlag) {
        await watchMode();
      } else {
        // Cleanup watchers after a short delay if not in watch mode
        setTimeout(() => {
          cleanup();
        }, 5000);
      }
      break;
  }
}

// Run
main().catch(error => {
  console.error('Error:', error);
  cleanup();
  process.exit(1);
});
#!/usr/bin/env node

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const { detect } = require('detect-port');
const chokidar = require('chokidar');
const dayjs = require('dayjs');
const relativeTime = require('dayjs/plugin/relativeTime');

dayjs.extend(relativeTime);

// Configuration
const DEV_DIR = path.join(process.cwd(), '.wingman-dev');
const PID_DIR = path.join(DEV_DIR, 'pids');
const BUILD_STATS_FILE = path.join(DEV_DIR, 'build-stats.json');

// Color codes for services
const COLORS = {
  server: '\x1b[34m',     // blue
  extension: '\x1b[32m',  // green  
  preview: '\x1b[36m',    // cyan
  demo: '\x1b[33m',       // yellow
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  gray: '\x1b[90m',
  red: '\x1b[31m'
};

const SERVICES = {
  server: {
    name: 'Relay Server',
    command: 'cd packages/relay-server && NODE_ENV=development npm run dev',
    defaultPort: 8787,
    pidFile: 'server.pid',
    watchPaths: ['packages/relay-server/src'],
    distPath: 'packages/relay-server/dist',
    color: COLORS.server,
    prefix: 'SERVER'
  },
  extension: {
    name: 'Chrome Extension', 
    command: 'cd packages/chrome-extension && NODE_ENV=development npm run dev',
    defaultPort: null,
    pidFile: 'extension.pid',
    watchPaths: ['packages/chrome-extension/src'],
    distPath: 'packages/chrome-extension/dist',
    color: COLORS.extension,
    prefix: 'EXTENSION'
  },
  preview: {
    name: 'Preview UI',
    command: 'cd packages/preview-ui && npm run dev',
    defaultPort: 3001,
    pidFile: 'preview.pid',
    watchPaths: ['packages/preview-ui/src'],
    distPath: 'packages/preview-ui/dist',
    color: COLORS.preview,
    prefix: 'PREVIEW'
  },
  demo: {
    name: 'Demo App',
    command: 'cd demo-app && npm run dev',
    defaultPort: 5173,
    pidFile: 'demo.pid',
    watchPaths: ['demo-app/src'],
    distPath: 'demo-app/dist',
    color: COLORS.demo,
    prefix: 'DEMO'
  }
};

// Global state
let buildStats = {};
let watchers = [];
let logStreams = [];

// Ensure directories exist
function ensureDirectories() {
  [DEV_DIR, PID_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
}

// Load build stats
function loadBuildStats() {
  if (fs.existsSync(BUILD_STATS_FILE)) {
    try {
      buildStats = JSON.parse(fs.readFileSync(BUILD_STATS_FILE, 'utf8'));
    } catch (e) {
      buildStats = {};
    }
  }
}

// Scan existing build artifacts to initialize build times
function scanBuildTimes() {
  Object.entries(SERVICES).forEach(([key, service]) => {
    const distPath = path.join(process.cwd(), service.distPath);
    
    // Check if dist directory exists
    if (fs.existsSync(distPath)) {
      try {
        // Get the most recent modification time from dist directory
        const stats = fs.statSync(distPath);
        let mostRecentTime = stats.mtime;
        
        // Check a few key files in the dist directory for more accurate timing
        const filesToCheck = ['index.js', 'index.html', 'manifest.json', 'main.js'];
        
        for (const file of filesToCheck) {
          const filePath = path.join(distPath, file);
          if (fs.existsSync(filePath)) {
            const fileStats = fs.statSync(filePath);
            if (fileStats.mtime > mostRecentTime) {
              mostRecentTime = fileStats.mtime;
            }
          }
        }
        
        // Initialize or update build stats
        if (!buildStats[key]) {
          buildStats[key] = {};
        }
        
        // Only update if we don't have a build time or if the status is "building"
        if (!buildStats[key].lastBuild || buildStats[key].status === 'building') {
          buildStats[key].lastBuild = mostRecentTime.toISOString();
          buildStats[key].status = 'success';
        }
      } catch (e) {
        // If we can't read the directory, don't update build stats
        console.error(`Warning: Could not scan ${service.distPath}: ${e.message}`);
      }
    } else {
      // If dist doesn't exist and status is "building", clear it
      if (buildStats[key] && buildStats[key].status === 'building') {
        delete buildStats[key].status;
        delete buildStats[key].lastBuild;
      }
    }
  });
  
  saveBuildStats();
}

// Save build stats
function saveBuildStats() {
  fs.writeFileSync(BUILD_STATS_FILE, JSON.stringify(buildStats, null, 2));
}

// Check if a process is running
function isProcessRunning(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch (e) {
    return false;
  }
}

// Read PID from file
function readPidFile(filename) {
  const pidPath = path.join(PID_DIR, filename);
  if (fs.existsSync(pidPath)) {
    const content = fs.readFileSync(pidPath, 'utf8').trim();
    const pid = parseInt(content);
    if (!isNaN(pid)) {
      return pid;
    }
  }
  return null;
}

// Write PID to file
function writePidFile(filename, pid) {
  const pidPath = path.join(PID_DIR, filename);
  fs.writeFileSync(pidPath, pid.toString());
}

// Remove PID file
function removePidFile(filename) {
  const pidPath = path.join(PID_DIR, filename);
  if (fs.existsSync(pidPath)) {
    fs.unlinkSync(pidPath);
  }
}

// Format build time
function formatBuildTime(serviceKey) {
  const stats = buildStats[serviceKey];
  if (!stats || !stats.lastBuild) {
    return 'Never';
  }
  
  if (stats.status === 'building') {
    return 'Building...';
  }
  
  const buildTime = dayjs(stats.lastBuild);
  const now = dayjs();
  const diffMinutes = now.diff(buildTime, 'minute');
  
  if (diffMinutes < 1) {
    return 'Just now';
  } else if (diffMinutes < 60) {
    return `${diffMinutes}m ago`;
  } else if (diffMinutes < 1440) {
    const hours = Math.floor(diffMinutes / 60);
    return `${hours}h ago`;
  } else {
    return buildTime.format('MMM DD HH:mm');
  }
}

// Get service status
async function getServiceStatus(serviceKey, service) {
  const pid = readPidFile(service.pidFile);
  
  if (pid && isProcessRunning(pid)) {
    let port = service.defaultPort;
    
    // Check if port is actually in use
    if (port) {
      try {
        const availablePort = await detect(port);
        if (availablePort !== port) {
          // Port is in use, likely by our service
          return {
            status: 'running',
            pid,
            port
          };
        } else {
          // Port is free but process is running (might be starting up)
          return {
            status: 'running',
            pid,
            port: port
          };
        }
      } catch (e) {
        // Error checking port, assume service is running
        return {
          status: 'running',
          pid,
          port: port || '-'
        };
      }
    }
    
    return {
      status: 'running',
      pid,
      port: '-'
    };
  } else {
    // Clean up stale PID file
    if (pid) {
      removePidFile(service.pidFile);
    }
    return {
      status: 'stopped',
      pid: null,
      port: null
    };
  }
}

// Print status table
async function printStatus(showTimestamp = false) {
  console.log('\n╔═══════════════════════════════════════════════════════════════════╗');
  console.log('║                    🛩️  Wingman Control Tower                      ║');
  console.log('╠═══════════════════════════════════════════════════════════════════╣');
  console.log('║ Service          │ Status    │  PID  │ Port │ Last Built         ║');
  console.log('╟──────────────────┼───────────┼───────┼──────┼────────────────────╢');
  
  let allRunning = true;
  let anyRunning = false;
  
  for (const [key, service] of Object.entries(SERVICES)) {
    const status = await getServiceStatus(key, service);
    const statusText = status.status === 'running' ? '● Running' : '○ Stopped';
    const statusColor = status.status === 'running' ? '\x1b[32m' : '\x1b[31m';
    const reset = '\x1b[0m';
    
    if (status.status === 'running') {
      anyRunning = true;
    } else {
      allRunning = false;
    }
    
    const pidDisplay = status.pid ? status.pid.toString() : '-';
    const portDisplay = status.port ? status.port.toString() : '-';
    
    const buildTime = formatBuildTime(key);
    
    console.log(
      `║ ${service.name.padEnd(16)} │ ${statusColor}${statusText.padEnd(9)}${reset} │ ${
        pidDisplay.padEnd(5)
      } │ ${portDisplay.padEnd(4)} │ ${buildTime.padEnd(18)} ║`
    );
  }
  
  console.log('╚══════════════════╧═══════════╧═══════╧══════╧════════════════════╝');
  
  if (showTimestamp) {
    console.log(`\n Last updated: ${dayjs().format('HH:mm:ss')}`);
  }
  
  return { allRunning, anyRunning };
}

// Start a service
async function startService(serviceKey, service) {
  const existingPid = readPidFile(service.pidFile);
  
  if (existingPid && isProcessRunning(existingPid)) {
    console.log(`  ${service.name} is already running (PID: ${existingPid})`);
    return existingPid;
  }
  
  if (service.defaultPort) {
    const availablePort = await detect(service.defaultPort);
    if (availablePort !== service.defaultPort) {
      console.log(`  ⚠️  Port ${service.defaultPort} is already in use for ${service.name}`);
    }
  }
  
  console.log(`  Starting ${service.name}...`);
  
  const logFile = path.join(DEV_DIR, `${serviceKey}.log`);
  
  // Clear log file before starting
  fs.writeFileSync(logFile, '');
  
  // Open log file for appending
  const out = fs.openSync(logFile, 'a');
  const err = fs.openSync(logFile, 'a');
  
  try {
    // Parse the command to extract the working directory and actual command
    const commandParts = service.command.split(' && ');
    let cwd = process.cwd();
    let actualCommand = service.command;
    
    // If command starts with 'cd', extract the directory and command
    if (commandParts.length === 2 && commandParts[0].startsWith('cd ')) {
      cwd = path.join(process.cwd(), commandParts[0].substring(3));
      actualCommand = commandParts[1];
    }
    
    // Set up environment
    const env = { ...process.env };
    if (actualCommand.includes('NODE_ENV=development')) {
      env.NODE_ENV = 'development';
      actualCommand = actualCommand.replace('NODE_ENV=development ', '');
    }
    
    // Parse npm command
    const args = actualCommand.trim().split(' ');
    const command = args[0];
    const commandArgs = args.slice(1);
    
    // Spawn the process
    const child = spawn(command, commandArgs, {
      cwd: cwd,
      env: env,
      detached: true,
      stdio: ['ignore', out, err]
    });
    
    // Unref the child so the parent can exit
    child.unref();
    
    if (child.pid) {
      writePidFile(service.pidFile, child.pid);
      console.log(`  ✓ ${service.name} started (PID: ${child.pid})`);
      
      // Close file descriptors
      fs.closeSync(out);
      fs.closeSync(err);
      
      return child.pid;
    } else {
      console.log(`  ✗ Failed to start ${service.name}: No PID`);
      fs.closeSync(out);
      fs.closeSync(err);
    }
  } catch (error) {
    console.log(`  ✗ Failed to start ${service.name}: ${error.message}`);
    try {
      fs.closeSync(out);
      fs.closeSync(err);
    } catch {}
  }
  
  return null;
}

// Format log line with service prefix and timestamp
function formatLogLine(serviceKey, line) {
  const service = SERVICES[serviceKey];
  const timestamp = dayjs().format('HH:mm:ss');
  const prefix = `${service.color}[${timestamp}] [${service.prefix}]${COLORS.reset}`;
  return `${prefix} ${line}`;
}

// Stream logs from a specific service
function streamServiceLogs(serviceKey, follow = true) {
  const service = SERVICES[serviceKey];
  const logFile = path.join(DEV_DIR, `${serviceKey}.log`);
  
  if (!fs.existsSync(logFile)) {
    console.log(formatLogLine(serviceKey, `${COLORS.gray}No log file found${COLORS.reset}`));
    return null;
  }
  
  const args = follow ? ['-f', logFile] : ['-n', '50', logFile];
  const tail = spawn('tail', args);
  
  tail.stdout.on('data', (data) => {
    const lines = data.toString().split('\n').filter(line => line.trim());
    lines.forEach(line => {
      console.log(formatLogLine(serviceKey, line));
    });
  });
  
  tail.stderr.on('data', (data) => {
    console.error(formatLogLine(serviceKey, `${COLORS.red}${data.toString()}${COLORS.reset}`));
  });
  
  tail.on('error', (error) => {
    console.error(formatLogLine(serviceKey, `${COLORS.red}Error: ${error.message}${COLORS.reset}`));
  });
  
  return tail;
}

// Stream logs from all services
async function streamAllLogs(follow = true) {
  console.log(`${COLORS.bold}\n📜 Streaming logs from all services...\n${COLORS.reset}`);
  console.log(`${COLORS.gray}Press Ctrl+C to stop\n${COLORS.reset}`);
  
  // Start streaming from each service
  for (const [key, service] of Object.entries(SERVICES)) {
    const status = await getServiceStatus(key, service);
    if (status.status === 'running' || !follow) {
      const stream = streamServiceLogs(key, follow);
      if (stream) {
        logStreams.push(stream);
      }
    }
  }
  
  if (logStreams.length === 0) {
    console.log(`${COLORS.demo}No running services found\n${COLORS.reset}`);
    return;
  }
  
  // Handle cleanup on exit
  process.on('SIGINT', () => {
    cleanupLogStreams();
    console.log(`${COLORS.extension}\n\n✅ Log streaming stopped\n${COLORS.reset}`);
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    cleanupLogStreams();
    process.exit(0);
  });
}

// Clean up log streams
function cleanupLogStreams() {
  logStreams.forEach(stream => {
    if (stream && !stream.killed) {
      stream.kill('SIGTERM');
    }
  });
  logStreams = [];
}

// Show log info
function showLogInfo() {
  console.log(`${COLORS.bold}\n📊 Log File Information\n${COLORS.reset}`);
  console.log(`${COLORS.gray}${'─'.repeat(60)}${COLORS.reset}`);
  
  for (const [key, service] of Object.entries(SERVICES)) {
    const logFile = path.join(DEV_DIR, `${key}.log`);
    
    if (fs.existsSync(logFile)) {
      const stats = fs.statSync(logFile);
      const sizeKB = (stats.size / 1024).toFixed(2);
      const modified = dayjs(stats.mtime).format('MMM DD HH:mm:ss');
      
      console.log(`${service.color}${service.prefix.padEnd(10)}${COLORS.reset} │ ${logFile}`);
      console.log(`           │ Size: ${sizeKB} KB, Modified: ${modified}`);
    } else {
      console.log(`${service.color}${service.prefix.padEnd(10)}${COLORS.reset} │ ${COLORS.gray}No log file${COLORS.reset}`);
    }
    console.log(`${COLORS.gray}${'─'.repeat(60)}${COLORS.reset}`);
  }
  console.log('');
}

// Clear log files
function clearLogs(serviceKey = null) {
  if (serviceKey) {
    const logFile = path.join(DEV_DIR, `${serviceKey}.log`);
    if (fs.existsSync(logFile)) {
      fs.writeFileSync(logFile, '');
      console.log(`${COLORS.extension}✓ Cleared log file for ${SERVICES[serviceKey].name}${COLORS.reset}`);
    } else {
      console.log(`${COLORS.demo}No log file found for ${SERVICES[serviceKey].name}${COLORS.reset}`);
    }
  } else {
    // Clear all log files
    console.log(`${COLORS.bold}\n🧹 Clearing all log files...\n${COLORS.reset}`);
    
    for (const [key, service] of Object.entries(SERVICES)) {
      const logFile = path.join(DEV_DIR, `${key}.log`);
      if (fs.existsSync(logFile)) {
        fs.writeFileSync(logFile, '');
        console.log(`${COLORS.extension}✓ Cleared ${service.name} logs${COLORS.reset}`);
      }
    }
    console.log(`${COLORS.extension}\n✅ All log files cleared\n${COLORS.reset}`);
  }
}

// Stop a service
async function stopService(serviceKey, service) {
  const pid = readPidFile(service.pidFile);
  
  if (!pid) {
    console.log(`  ${service.name} is not running`);
    return;
  }
  
  if (!isProcessRunning(pid)) {
    console.log(`  ${service.name} PID file exists but process is not running`);
    removePidFile(service.pidFile);
    return;
  }
  
  try {
    // Try to kill the process group first (negative PID)
    try {
      process.kill(-pid, 'SIGTERM');
    } catch (e) {
      // If process group kill fails, try individual process
      process.kill(pid, 'SIGTERM');
    }
    
    // Give it a moment to shut down gracefully
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Check if still running and force kill if necessary
    if (isProcessRunning(pid)) {
      try {
        process.kill(-pid, 'SIGKILL');
      } catch (e) {
        process.kill(pid, 'SIGKILL');
      }
    }
    
    removePidFile(service.pidFile);
    console.log(`  ✓ ${service.name} stopped (PID: ${pid})`);
  } catch (error) {
    // Process might have already exited
    if (error.code !== 'ESRCH') {
      console.log(`  ✗ Failed to stop ${service.name}: ${error.message}`);
    } else {
      removePidFile(service.pidFile);
      console.log(`  ✓ ${service.name} stopped`);
    }
  }
}

// Start all services
async function startAll(showLogs = false) {
  console.log('\n🚀 Starting Wingman services...\n');
  for (const [key, service] of Object.entries(SERVICES)) {
    await startService(key, service);
    await new Promise(resolve => setTimeout(resolve, 1500));
  }
  console.log('\n✅ All services started\n');
  
  if (showLogs) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    await streamAllLogs(true);
  }
}

// Stop all services
async function stopAll() {
  console.log('\n🛑 Stopping Wingman services...\n');
  for (const [key, service] of Object.entries(SERVICES)) {
    await stopService(key, service);
  }
  console.log('\n✅ All services stopped\n');
}

// Setup file watchers for build detection
function setupWatchers() {
  // Clear existing watchers
  watchers.forEach(w => w.close());
  watchers = [];
  
  Object.entries(SERVICES).forEach(([key, service]) => {
    // Watch dist directory for build completions
    const distPath = path.join(process.cwd(), service.distPath);
    
    if (fs.existsSync(path.dirname(distPath))) {
      const watcher = chokidar.watch(distPath, {
        persistent: true,
        ignoreInitial: false, // Changed to false to detect initial files
        depth: 2, // Increased depth to catch more build artifacts
        awaitWriteFinish: {
          stabilityThreshold: 500,
          pollInterval: 100
        }
      });
      
      // Handle both 'add' and 'change' events for build detection
      const updateBuildSuccess = () => {
        if (!buildStats[key]) {
          buildStats[key] = {};
        }
        buildStats[key].lastBuild = new Date().toISOString();
        buildStats[key].status = 'success';
        saveBuildStats();
      };
      
      watcher.on('change', updateBuildSuccess);
      watcher.on('add', updateBuildSuccess);
      
      watchers.push(watcher);
    }
    
    // Watch source directories to detect when builds start
    service.watchPaths.forEach(watchPath => {
      const fullPath = path.join(process.cwd(), watchPath);
      
      if (fs.existsSync(fullPath)) {
        const sourceWatcher = chokidar.watch(fullPath, {
          persistent: true,
          ignoreInitial: true,
          ignored: /node_modules|\.git/
        });
        
        sourceWatcher.on('change', () => {
          if (!buildStats[key]) {
            buildStats[key] = {};
          }
          // Mark as building when source changes, but only if we have a previous successful build
          if (buildStats[key].lastBuild && buildStats[key].status !== 'building') {
            buildStats[key].status = 'building';
            saveBuildStats();
          }
        });
        
        watchers.push(sourceWatcher);
      }
    });
  });
}

// Cleanup watchers
function cleanup() {
  watchers.forEach(w => w.close());
  cleanupLogStreams();
}

// Watch mode
async function watchMode() {
  setupWatchers();
  
  // Clear screen and show initial status
  console.clear();
  await printStatus(true);
  console.log('\n 👀 Watching for changes... (Press Ctrl+C to exit)\n');
  
  // Update every 2 seconds
  const interval = setInterval(async () => {
    console.clear();
    await printStatus(true);
    console.log('\n 👀 Watching for changes... (Press Ctrl+C to exit)\n');
  }, 2000);
  
  // Handle exit
  process.on('SIGINT', () => {
    clearInterval(interval);
    cleanup();
    console.log('\n\n✅ Watch mode stopped\n');
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    clearInterval(interval);
    cleanup();
    process.exit(0);
  });
}

// Main function
async function main() {
  ensureDirectories();
  loadBuildStats();
  scanBuildTimes(); // Scan existing builds on startup
  
  const args = process.argv.slice(2);
  const command = args[0];
  const watchFlag = args.includes('--watch');
  const logsFlag = args.includes('--logs');
  
  switch (command) {
    case 'stop':
      await stopAll();
      break;
      
    case 'status':
      await printStatus();
      console.log('');
      break;
      
    case 'restart':
      await stopAll();
      await new Promise(resolve => setTimeout(resolve, 2000));
      await startAll(logsFlag);
      if (!logsFlag) {
        await printStatus();
        console.log('');
      }
      break;
      
    case 'logs':
      // Handle logs command
      const subCommand = args[1];
      
      if (subCommand === '--clear') {
        clearLogs();
      } else if (subCommand === '--info') {
        showLogInfo();
      } else if (subCommand && !subCommand.startsWith('--')) {
        // Stream logs for specific service
        if (SERVICES[subCommand]) {
          console.log(`${COLORS.bold}\n📜 Streaming logs for ${SERVICES[subCommand].name}...\n${COLORS.reset}`);
          console.log(`${COLORS.gray}Press Ctrl+C to stop\n${COLORS.reset}`);
          const stream = streamServiceLogs(subCommand, true);
          if (stream) {
            logStreams.push(stream);
            
            process.on('SIGINT', () => {
              cleanupLogStreams();
              console.log(`${COLORS.extension}\n\n✅ Log streaming stopped\n${COLORS.reset}`);
              process.exit(0);
            });
            
            process.on('SIGTERM', () => {
              cleanupLogStreams();
              process.exit(0);
            });
          }
        } else {
          console.log(`${COLORS.red}Unknown service: ${subCommand}${COLORS.reset}`);
          console.log(`${COLORS.gray}Available services: ${Object.keys(SERVICES).join(', ')}${COLORS.reset}`);
        }
      } else {
        // Stream all logs
        await streamAllLogs(true);
      }
      break;
      
    default:
      // Check if any services need starting
      let needStart = false;
      for (const [key, service] of Object.entries(SERVICES)) {
        const status = await getServiceStatus(key, service);
        if (status.status === 'stopped') {
          needStart = true;
          break;
        }
      }
      
      // Start services if needed
      if (needStart) {
        await startAll(logsFlag);
      } else if (logsFlag) {
        // If services are already running and --logs was passed, stream logs
        await streamAllLogs(true);
      }
      
      // Only show status and setup watchers if not streaming logs
      if (!logsFlag) {
        // Setup watchers to keep build stats updated (even in non-watch mode)
        setupWatchers();
        
        // Show status
        await printStatus();
        console.log('');
        
        // Enter watch mode if requested
        if (watchFlag) {
          await watchMode();
        } else {
          // Cleanup watchers after a short delay if not in watch mode
          setTimeout(() => {
            cleanup();
          }, 5000);
        }
      }
      break;
  }
}

// Run
main().catch(error => {
  console.error('Error:', error);
  cleanup();
  process.exit(1);
});